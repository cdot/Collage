import {promises as Fs } from "node:fs";
import { Layout } from "./Layout.js";
import { Image } from "./Image.js";

/**
 * Class that manages construction of a set of Layouts from a set of
 * images.
 */
class Collage {
  
  /**
   * Process all images from the source directory.
   * @param {Rect} bounds size of layout
   * @param {Rect} minr minimum rectangle size
   * @param {Image[]} images the set of images
   */
  constructor(bounds, minr, images) {
    /**
     * @param {Rect} bounds of the layout
     * @member {Rect}
     */
    this.bounds = bounds;
    /** 
     * X and Y minimums
     * @member {Rect}
     */
    this.minr = minr;
    /**
     * @member {Image[]} set of images to place
     */
    this.images = images;
    /**
     * Layouts generated by planning
     * @member {Layout[]}
     */
    this.layouts = [];
  }

  /**
   * Pack images into layouts. This doesn't perform any actual operations
   * on the images, it just plans the layouts.
   * @param {String} algorithm the best-fit algorithm to use.
   * * AREA - the cost is the total of the wasted area (default)
   * * AXIS - the cost is the minimum of the waste along the X or Y axis
   */
  plan_layouts(algorithm) {
    console.debug(`Building layouts for ${this.images.length} images`);

    this.layouts = [];
    for (const image of this.images) {
      console.debug(`Placing "${image}"`);
      if (image.scale_to_fit(this.bounds) !== 1)
        console.debug(`\tscaled ${image.geometry}`);
      let best_space, cheapest = Number.MAX_SAFE_INTEGER;
      for (const layout of this.layouts) {
        for (const space of layout.spaces) {
          if (space.image)
            continue;
          let fit = space.image_fits(image);
          if (fit) {
            let cost;
            switch (algorithm) {
            default:
              cost = fit.w * fit.h;
              break;
            case "AXIS":
              cost = Math.min(fit.w, fit.h);
              break;
            }
            if (cost < cheapest) {
              cheapest = cost;
              best_space = space;
            }
          }
        }
      }
      if (!best_space) {
        // Create a new layout and put the image there
        console.debug(`Create new layout for ${image.toString()}`);
        const layout = new Layout(this.bounds, this.minr);
        best_space = layout.spaces[0];
        this.layouts.push(layout);
      }
      best_space.place_image(image, this.minr);
    }
  }

  /**
   * Construct new images from the layouts that contain more than one
   * locked space.
   * @param {String} destdir destination directory for images
   * @return {Promise} Promise that resolves when all compositions are done
   */
  compose_layouts(destdir) {
    const promises = [];
    for (const lo of this.layouts) {
      if (lo.simplify() > 0)
        promises.push(lo.construct_image(destdir));
    }
    return Promise.all(promises);
  }
}

export { Collage };
